const Model = require('./base.js')
const crypto = require('crypto')
const jwt = require('jsonwebtoken')
const logger = require('../configs/logger.js')
const objection = require('objection')
const knex = require('../configs/db.js');

// Related Models
const Role = require('./role.js')
const Course = require('./course.js')
const CourseStudent = require('./courseStudent.js')
const CourseInstructor = require('./courseInstructor.js')

//Random function for WID testing for now
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       required:
 *         - email
 *       properties:
 *         id:
 *           type: integer
 *           description: autogenerated id
 *         email:
 *           type: email
 *           description: Email address of the user
 *         roles:
 *           type: array
 *           items:
 *             $ref: '#/components/schemas/Role'
 *       example:
 *           id: 1
 *           email: test-admin
 *           name: Test Administrator
 *           roles:
 *             - id: 1
 *               name: admin
 *
 */

class User extends Model {
  // Table name is the only required property.
  static get tableName() {
    return 'users'
  }

  // Each model must have a column (or a set of columns) that uniquely
  // identifies the rows. The column(s) can be specified using the `idColumn`
  // property. `idColumn` returns `id` by default and doesn't need to be
  // specified unless the model's primary key is something else.
  static get idColumn() {
    return 'id'
  }


  //Method used to find or create a user, which is then passed into the web token
  static async findOrCreate(email, wid) {
    let user = await User.query().where('email', email).limit(1)
    // user not found - create user
    if (user.length === 0) {
      user = [
        await User.query().insert({
          email: email,
          eid: email,
          wid: wid,
          first_name: email,
          last_name: email,
          profile_updated: false
        }),
      ]
      const defaultRoleId = 1;  // Assuming the default role has id 1

      // Insert into the user_roles table
      await User.relatedQuery('roles') 
        .for(user[0].id) 
        .relate(defaultRoleId);
      logger.info('User ' + email + ' created')
    }
    return user[0]
  }

  //Method used when importing enrollment information from the file
  static async addEnrollment(enrollmentLine) {
    let user = await User.query().where('wid', enrollmentLine["Student ID"]).limit(1)
    //If there isn't a user
    if (user.length === 0) {
      const studentName = enrollmentLine["Student Name"].split(', ')
      //Copying this from the method above since we have more information than it expects
      //Could make the method above more robust and just use it, currently not worried about that
      user = [
        await User.query().insert({
          email: enrollmentLine["Email"],
          eid: enrollmentLine["Email"],
          wid: enrollmentLine["Student ID"],
          first_name: studentName[1],
          last_name: studentName[0],
          profile_updated: false
        }),
      ]
      const defaultRoleId = 1;  // Assuming the default role has id 1

      // Insert into the user_roles table
      await User.relatedQuery('roles') 
        .for(user[0].id) 
        .relate(defaultRoleId);
      logger.info('User ' + email + ' created')
    }
    const splitDate = enrollmentLine["Start Date"].split('/')
    const termCode = Course.createTermCode(splitDate[2], splitDate[1], splitDate[0])

    //Find or create the course the line is talking about
    let enrolledCourse = await Course.find(enrollmentLine["Enrollment Course Number"], termCode)
    if (enrolledCourse === undefined) {
      enrolledCourse = await Course.create(enrollmentLine["Enrollment Course Name"], enrollmentLine["Enrollment Course Number"],
        enrollmentLine["Enrollment Section Name"], enrollmentLine["Credit Hours"], termCode
      )
    }
    //And finally connect the two, adding all of the information that needs
    await User.relatedQuery('course_students')
      .for(user[0].id)
      .relate({
        id: enrolledCourse.id,
        grade: enrollmentLine["Final Grade"], 
        ignore_in_gpa: false, 
        dropped: enrollmentLine["Dropped?"], 
        dropped_date: enrollmentLine["Dropped Date"], 
        last_attendance: enrollmentLine["Last Date of Attendance"], 
        midterm_grade: enrollmentLine["Midterm Grade"]})

    //And by finally, I mean we still need to connect the instructor
    //I'm pretty sure I'll need to learn regexs for this, as the instructor string is "LastName, FirstName (WID) <email>"
    //or I could try to come up with some really cursed split scheme
    //might just be a task I'd leave for the next group

  }

  // static async findByRefreshToken(token) {
  //   let user = await User.query().where('refresh_token', token).limit(1)
  //   if (user.length === 0) {
  //     return null
  //   }
  //   return user[0]
  // }

  async updateRefreshToken() {
    var token = this.refresh_token
    if (!token) {
      token = crypto.randomBytes(32).toString('hex')
      await this.$query().patch({
        refresh_token: token,
      })
    }
    const refresh_token = jwt.sign(
      {
        user_id: this.id,
        refresh_token: token,
      },
      process.env.TOKEN_SECRET,
      {
        expiresIn: '6h',
      }
    )
    return refresh_token
  }

  static async get_academics(user_id) {
    try {
      const status = await knex('users') 
        .join('academic_status', 'users.id', '=', 'academic_status.user_id')
        .where('users.id', user_id) 
        .select('user_id', 'gpa', 'warning', 'probation'); 
        return status;
    } catch (err) {
      console.error('Error when fetching academic status:', err);
      throw err;
    }
  }

  async get_admin() {
    const roles = await this.$relatedQuery('roles').for(this.id).select('name')
    //Roles for current user
    return roles.some((r) => r.name === 'admin')
  }

  async is_api() {
    const roles = await this.$relatedQuery('roles').for(this.id).select('name')
    //Roles for current user
    return roles.some((r) => r.name === 'api')
  }
  
  static async updateUserRoles(userId, roles) {
    try {
      // Get the user
      const user = await User.query().findById(userId);
  
      if (!user) {
        throw new Error(`User with ID ${userId} not found.`);
      }
  
      // Remove all current roles for the user
      await user.$relatedQuery('roles').unrelate();

      if (Array.isArray(roles) && roles.length > 0) {
       //Get the role id based on the names provided
        const roleRecords = await Role.query()
          .whereIn('name', roles)
          .select('id');
        
        //Add the new roles
        await user.$relatedQuery('roles').relate(
          roleRecords.map(role => ({ id: role.id }))
        );
      }
  
      return true;
    } catch (err) {
      logger.error('Error updating user roles:', err);
      throw err;
    }
  }

  async get_roles(){
    const roles = await this.$relatedQuery('roles').for(this.id).select('name')
    //Roles for current user
    return roles.map(role => role.name)
  }

  static async getToken(id) {
    let user = await User.query().findById(id)
    // tokens are currently only for users with 'api' or 'admin' roles
    // should change this to pass role information in the token, and attach middleware to the api routes that should be admin only
    const roles = await user.get_roles()
    if (roles) {
    //Can pass role information in the token here,
    //then use middleware like admin-required to check roles when accessing a route.
      const token = jwt.sign(
        {
          user_id: id,
          email: user.email,
          roles: roles,
          //refresh_token: refresh_token,
          profile_updated: user.profile_updated
        },
        process.env.TOKEN_SECRET,
        {
          expiresIn: '30m',
        }
      )
      return token
    } else {
      logger.info(
        'User ' +
          user.email +
          ' does not have an api or admin role but requested a token'
      )
      return null
    }
  }

  static async clearRefreshToken(id) {
    await User.query().findById(id).patch({
      refresh_token: null,
    })
  }

  // Optional JSON schema. This is not the database schema!
  // No tables or columns are generated based on this. This is only
  // used for input validation. Whenever a model instance is created
  // either explicitly or implicitly it is checked against this schema.
  // See http://json-schema.org/ for more info.
  static get jsonSchema() {
    return {
      type: 'object',
      required: ['email'],

      properties: {
        email: { type: 'string', format: 'email' },
      },
    }
  }
  // query to grab all users with all propertires, discord id, and all roles. 
  static async queryAllUsers() {
    const allUsers = await this.query()
      .leftJoin('user_discord', 'users.id', 'user_discord.user_id')
      .leftJoin('user_roles', 'users.id', 'user_roles.user_id')
      .leftJoin('roles', 'user_roles.role_id', 'roles.id')
      .select(
        'users.*',
        'user_discord.discord_id',
        knex.raw(`COALESCE(json_agg(roles.name) FILTER (WHERE roles.name IS NOT NULL), '[]') AS roles`)
      )
      .groupBy('users.id', 'user_discord.discord_id');
  
    return allUsers;
  }
  // This object defines the relations to other models.
  static get relationMappings() {
    return {
      roles: {
        relation: Model.ManyToManyRelation,
        modelClass: Role,
        join: {
          from: 'users.id',
          // ManyToMany relation needs the `through` object
          // to describe the join table.
          through: {
            // If you have a model class for the join table
            // you need to specify it like this:
            // modelClass: PersonMovie,
            from: 'user_roles.user_id',
            to: 'user_roles.role_id',
          },
          to: 'roles.id',
        },
        filter: (builder) => builder.select('id'),
      },
      course_students: {
        relation: Model.ManyToManyRelation,
        modelClass: Course,
        join: {
          from: 'users.id',
          through: {
            modelClass: CourseStudent,
            from: 'course_students.user_id',
            to: 'course_students.course_id',
            extra:['grade', 'ignore_in_gpa', 'dropped', 'dropped_date', 'last_attendance', 'midterm_grade']
          },
          to: 'courses.id'
        }
      },
      course_instructors: {
        relation: Model.ManyToManyRelation,
        modelClass: Course,
        join: {
          from: 'users.id',
          through: {
            modelClass: CourseInstructor,
            from: 'course_instructors.user_id',
            to: 'course_instructors.course_id'
          },
          to: 'courses.id'
        }
      }
    }
  }

  async $beforeInsert() {
    //this.slug = nanoid()
    let user = await User.query().where('email', this.email).limit(1)
    // Email is already in use
    if (user.length !== 0) {
      throw new objection.ValidationError({
        message: 'email should be unique',
        type: 'ModelValidation',
        data: {
          email: [
            {
              message: 'this email is already in use',
            },
          ],
        },
      })
    }
  }
}

module.exports = User